#!/usr/bin/env python3
"""
SHA3 RSP Parser

This script parses NIST SHA3-256 .rsp files and generates C header files with test vectors.
It supports both regular test vectors (ShortMsg, LongMsg) and Monte Carlo test vectors.

Usage:
    python parse_sha3_rsp.py -o sha3_test_vectors.h SHA3_256ShortMsg.rsp SHA3_256LongMsg.rsp
    python parse_sha3_rsp.py -o sha3_monte_vectors.h SHA3_256Monte.rsp
"""

import re
import argparse
import os

def generate_c_header(test_vectors, vector_type="regular"):
    """
    Generates the C header file content from a list of test vectors.

    Args:
        test_vectors (list): A list of dictionaries, where each dictionary
                             represents a test vector with 'message' and 'hash'.
                             For Monte Carlo: 'seed', 'count', and 'hash'.
        vector_type (str): Type of vectors - "regular" or "monte"

    Returns:
        str: The complete C header file content as a string.
    """
    header_content = []
    header_content.append("/* This file is automatically generated. Do not edit. */\n")
    
    if vector_type == "monte":
        header_content.append("#ifndef SHA3_256_MONTE_TEST_VECTORS_H")
        header_content.append("#define SHA3_256_MONTE_TEST_VECTORS_H")
        header_content.append("\n#include <stdint.h>")
        header_content.append("#include <stddef.h>\n")
        header_content.append("typedef struct {")
        header_content.append("    const uint8_t seed[32];")
        header_content.append("    const uint32_t count;")
        header_content.append("    const uint8_t expected_hash[32];")
        header_content.append("} SHA3MonteTestVector;\n")
        
        # Define the main test vector array for Monte Carlo
        header_content.append("static const SHA3MonteTestVector sha3_256_monte_test_vectors[] = {")
        for vector in test_vectors:
            seed_hex = ", ".join([f"0x{byte:02x}" for byte in vector['seed']])
            hash_hex = ", ".join([f"0x{byte:02x}" for byte in vector['hash']])
            header_content.append(f"    {{{{{seed_hex}}}, {vector['count']}, {{{hash_hex}}} }},")
        
        header_content.append("};")
        header_content.append(f"\nstatic const size_t num_sha3_256_monte_test_vectors = {len(test_vectors)};\n")
        header_content.append("#endif // SHA3_256_MONTE_TEST_VECTORS_H")
        
    else:
        header_content.append("#ifndef SHA3_256_TEST_VECTORS_H")
        header_content.append("#define SHA3_256_TEST_VECTORS_H")
        header_content.append("\n#include <stdint.h>")
        header_content.append("#include <stddef.h>\n")
        header_content.append("typedef struct {")
        header_content.append("    const uint8_t *message;")
        header_content.append("    const size_t message_len;")
        header_content.append("    const uint8_t expected_hash[32];")
        header_content.append("} SHA3TestVector;\n")

        # Define all message and hash arrays first
        for i, vector in enumerate(test_vectors):
            # C-style hex format for byte arrays
            message_hex = ", ".join([f"0x{byte:02x}" for byte in vector['message']])
            hash_hex = ", ".join([f"0x{byte:02x}" for byte in vector['hash']])

            # For empty messages, C requires a specific syntax. We handle this in the struct literal.
            if vector['message']:
                header_content.append(f"static const uint8_t message_{i}[] = {{{message_hex}}};")
            header_content.append(f"static const uint8_t hash_{i}[32] = {{{hash_hex}}};")

        # Now, define the main test vector array
        header_content.append("\nstatic const SHA3TestVector sha3_256_test_vectors[] = {")
        for i, vector in enumerate(test_vectors):
            message_len = len(vector['message'])
            if message_len == 0:
                 # Handle the zero-length message case
                 header_content.append(f"    {{NULL, 0, {{ {', '.join([f'0x{byte:02x}' for byte in vector['hash']])} }} }},")
            else:
                 # Reference the message array and its size
                 header_content.append(f"    {{message_{i}, sizeof(message_{i}), {{ {', '.join([f'0x{byte:02x}' for byte in vector['hash']])} }} }},")

        header_content.append("};")
        header_content.append(f"\nstatic const size_t num_sha3_256_test_vectors = {len(test_vectors)};\n")
        header_content.append("#endif // SHA3_256_TEST_VECTORS_H")

    return "\n".join(header_content)

def parse_regular_rsp_file(file_path):
    """
    Parses a NIST SHA3-256 .rsp file for regular test vectors (ShortMsg, LongMsg).

    Args:
        file_path (str): The path to the .rsp file.

    Returns:
        list: A list of test vectors, where each vector is a dictionary.
    """
    test_vectors = []
    with open(file_path, 'r') as f:
        content = f.read()

    # Regex to find all test vector blocks
    # Each block starts with 'Len' and contains 'Msg' and 'MD'
    blocks = re.findall(r'Len = (\d+)\nMsg = ([0-9a-fA-F]*)\nMD = ([0-9a-fA-F]{64})', content)

    for length, msg, md in blocks:
        length = int(length)

        # The length from NIST is in bits, we need bytes for the message
        # Handle the case where the message length is 0
        if length == 0:
            message_bytes = b''
        else:
            # For SHA3, the message length is in bits but we need to handle partial bytes
            # The hex string represents the message, and we need to extract the correct number of bits
            byte_len = (length + 7) // 8
            if msg:
                # Pad the message to the correct byte length if necessary
                msg_padded = msg.ljust(byte_len * 2, '0')
                message_bytes = bytes.fromhex(msg_padded)
                
                # If the length is not a multiple of 8, we need to mask the last byte
                if length % 8 != 0:
                    last_byte_bits = length % 8
                    mask = (0xFF << (8 - last_byte_bits)) & 0xFF
                    message_bytes = message_bytes[:-1] + bytes([message_bytes[-1] & mask])
            else:
                message_bytes = b'\x00' * byte_len

        # The hash is always 32 bytes (256 bits) for SHA3-256
        hash_bytes = bytes.fromhex(md)

        test_vectors.append({
            'message': message_bytes,
            'hash': hash_bytes
        })

    return test_vectors

def parse_monte_rsp_file(file_path):
    """
    Parses a NIST SHA3-256 Monte Carlo .rsp file.

    Args:
        file_path (str): The path to the .rsp file.

    Returns:
        list: A list of Monte Carlo test vectors, where each vector is a dictionary.
    """
    test_vectors = []
    with open(file_path, 'r') as f:
        content = f.read()

    # Extract the seed
    seed_match = re.search(r'Seed = ([0-9a-fA-F]{64})', content)
    if not seed_match:
        raise ValueError("No seed found in Monte Carlo file")
    
    seed_hex = seed_match.group(1)
    seed_bytes = bytes.fromhex(seed_hex)

    # Find all COUNT and MD pairs
    count_md_blocks = re.findall(r'COUNT = (\d+)\nMD = ([0-9a-fA-F]{64})', content)

    for count_str, md in count_md_blocks:
        count = int(count_str)
        hash_bytes = bytes.fromhex(md)

        test_vectors.append({
            'seed': seed_bytes,
            'count': count,
            'hash': hash_bytes
        })

    return test_vectors

def detect_file_type(file_path):
    """
    Detects whether a file is a Monte Carlo test or regular test file.
    
    Args:
        file_path (str): Path to the RSP file
        
    Returns:
        str: "monte" for Monte Carlo files, "regular" for others
    """
    filename = os.path.basename(file_path).lower()
    if 'monte' in filename:
        return "monte"
    return "regular"

def main():
    """
    Main function to parse command-line arguments and run the script.
    """
    parser = argparse.ArgumentParser(
        description="Parse one or more NIST SHA3-256 .rsp files and generate a single C header file.",
        epilog="Example: python %(prog)s -o sha3_tests.h rsp/SHA3_256ShortMsg.rsp rsp/SHA3_256LongMsg.rsp"
    )
    parser.add_argument(
        "-o", "--output",
        required=True,
        dest="output_file",
        help="The path for the output .h file."
    )
    parser.add_argument(
        "input_files",
        nargs='+',
        help="One or more input .rsp files to parse."
    )
    parser.add_argument(
        "--type",
        choices=["auto", "regular", "monte"],
        default="auto",
        help="Force the type of test vectors. 'auto' detects based on filename."
    )
    args = parser.parse_args()

    all_test_vectors = []
    parsed_files_count = 0
    vector_type = None
    
    for input_path in args.input_files:
        try:
            print(f"Parsing {input_path}...")
            
            # Determine file type
            if args.type == "auto":
                file_type = detect_file_type(input_path)
            else:
                file_type = args.type
            
            # Set the vector type for the output (all files should be the same type)
            if vector_type is None:
                vector_type = file_type
            elif vector_type != file_type:
                print(f"  -> Warning: Mixed file types detected. All files should be the same type.")
                print(f"     Expected: {vector_type}, Found: {file_type}")
                continue
            
            # Parse the file based on its type
            if file_type == "monte":
                test_vectors = parse_monte_rsp_file(input_path)
            else:
                test_vectors = parse_regular_rsp_file(input_path)
            
            if not test_vectors:
                print(f"  -> Warning: No test vectors found.")
            else:
                all_test_vectors.extend(test_vectors)
                print(f"  -> Found {len(test_vectors)} vectors (type: {file_type}).")
                parsed_files_count += 1
                
        except FileNotFoundError:
            print(f"  -> Error: File not found. Skipping.")
        except Exception as e:
            print(f"  -> An error occurred while parsing: {e}. Skipping.")

    if not all_test_vectors:
        print("\nNo test vectors were successfully parsed. Output file will not be generated.")
        return

    print(f"\nTotal test vectors collected: {len(all_test_vectors)} from {parsed_files_count} file(s).")
    print(f"Vector type: {vector_type}")

    try:
        c_header_content = generate_c_header(all_test_vectors, vector_type)
        with open(args.output_file, 'w') as f:
            f.write(c_header_content)
        print(f"Successfully created {args.output_file}.")
    except Exception as e:
        print(f"\nAn error occurred while writing the output file: {e}")

if __name__ == "__main__":
    main()
