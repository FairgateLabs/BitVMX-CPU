import re
import argparse

def generate_c_header(test_vectors):
    """
    Generates the C header file content from a list of test vectors.

    Args:
        test_vectors (list): A list of dictionaries, where each dictionary
                             represents a test vector with 'message' and 'hash'.

    Returns:
        str: The complete C header file content as a string.
    """
    header_content = []
    header_content.append("/* This file is automatically generated. Do not edit. */\n")
    header_content.append("#ifndef SHA256_TEST_VECTORS_H")
    header_content.append("#define SHA256_TEST_VECTORS_H")
    header_content.append("\n#include <stdint.h>")
    header_content.append("#include <stddef.h>\n")
    header_content.append("typedef struct {")
    header_content.append("    const uint8_t *message;")
    header_content.append("    const size_t message_len;")
    header_content.append("    const uint8_t expected_hash[32];")
    header_content.append("} TestVector;\n")

    # Define all message and hash arrays first
    for i, vector in enumerate(test_vectors):
        # C-style hex format for byte arrays
        message_hex = ", ".join([f"0x{byte:02x}" for byte in vector['message']])
        hash_hex = ", ".join([f"0x{byte:02x}" for byte in vector['hash']])

        # For empty messages, C requires a specific syntax. We handle this in the struct literal.
        if vector['message']:
            header_content.append(f"static const uint8_t message_{i}[] = {{{message_hex}}};")
        header_content.append(f"static const uint8_t hash_{i}[32] = {{{hash_hex}}};")

    # Now, define the main test vector array
    header_content.append("\nstatic const TestVector sha256_test_vectors[] = {")
    for i, vector in enumerate(test_vectors):
        message_len = len(vector['message'])
        if message_len == 0:
             # Handle the zero-length message case
             header_content.append(f"    {{NULL, 0, {{ {', '.join([f'0x{byte:02x}' for byte in vector['hash']])} }} }},")
        else:
             # Reference the message array and its size
             header_content.append(f"    {{message_{i}, sizeof(message_{i}), {{ {', '.join([f'0x{byte:02x}' for byte in vector['hash']])} }} }},")

    header_content.append("};")
    header_content.append(f"\nstatic const size_t num_sha256_test_vectors = {len(test_vectors)};\n")
    header_content.append("#endif // SHA256_TEST_VECTORS_H")

    return "\n".join(header_content)

def parse_rsp_file(file_path):
    """
    Parses a NIST .rsp file for SHA256 test vectors.

    Args:
        file_path (str): The path to the .rsp file.

    Returns:
        list: A list of test vectors, where each vector is a dictionary.
    """
    test_vectors = []
    with open(file_path, 'r') as f:
        content = f.read()

    # Regex to find all test vector blocks
    # Each block starts with 'Len' and contains 'Msg' and 'MD'
    blocks = re.findall(r'Len = (\d+)\nMsg = ([0-9a-fA-F]*)\nMD = ([0-9a-fA-F]{64})', content)

    for length, msg, md in blocks:
        length = int(length)

        # The length from NIST is in bits, we need bytes for the message
        # Handle the case where the message length is 0
        if length == 0:
            message_bytes = b''
        else:
            # The message length needs to be converted from bits to bytes.
            # The hex string needs to be padded with leading zeros to match the byte length.
            byte_len = (length + 7) // 8
            message_bytes = bytes.fromhex(msg.zfill(byte_len * 2))

        # The hash is always 32 bytes (256 bits)
        hash_bytes = bytes.fromhex(md)

        test_vectors.append({
            'message': message_bytes,
            'hash': hash_bytes
        })

    return test_vectors

def main():
    """
    Main function to parse command-line arguments and run the script.
    """
    parser = argparse.ArgumentParser(
        description="Parse one or more NIST SHA-256 .rsp files and generate a single C header file.",
        epilog="Example: python %(prog)s -o sha256_tests.h SHA256ShortMsg.rsp SHA256LongMsg.rsp"
    )
    parser.add_argument(
        "-o", "--output",
        required=True,
        dest="output_file",
        help="The path for the output .h file."
    )
    parser.add_argument(
        "input_files",
        nargs='+',
        help="One or more input .rsp files to parse."
    )
    args = parser.parse_args()

    all_test_vectors = []
    parsed_files_count = 0
    for input_path in args.input_files:
        try:
            print(f"Parsing {input_path}...")
            test_vectors = parse_rsp_file(input_path)
            if not test_vectors:
                print(f"  -> Warning: No test vectors found.")
            else:
                all_test_vectors.extend(test_vectors)
                print(f"  -> Found {len(test_vectors)} vectors.")
                parsed_files_count += 1
        except FileNotFoundError:
            print(f"  -> Error: File not found. Skipping.")
        except Exception as e:
            print(f"  -> An error occurred while parsing: {e}. Skipping.")

    if not all_test_vectors:
        print("\nNo test vectors were successfully parsed. Output file will not be generated.")
        return

    print(f"\nTotal test vectors collected: {len(all_test_vectors)} from {parsed_files_count} file(s).")

    try:
        c_header_content = generate_c_header(all_test_vectors)
        with open(args.output_file, 'w') as f:
            f.write(c_header_content)
        print(f"Successfully created {args.output_file}.")
    except Exception as e:
        print(f"\nAn error occurred while writing the output file: {e}")

if __name__ == "__main__":
    main()