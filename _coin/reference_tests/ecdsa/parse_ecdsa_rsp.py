#!/usr/bin/env python3
"""
ECDSA P-256 SHA-256 RSP Parser

This script parses NIST ECDSA .rsp files and generates C header files with P-256 SHA-256 test vectors.
It supports both signature generation (SigGen) and signature verification (SigVer) test vectors.

Usage:
    python parse_ecdsa_rsp.py -o ecdsa_test_vectors.h rsp/SigVer.rsp
    python parse_ecdsa_rsp.py -o ecdsa_siggen_vectors.h rsp/SigGen.rsp rsp/SigGen.txt
"""

import re
import argparse
import os

def generate_c_header(test_vectors, vector_type="sigver"):
    """
    Generates the C header file content from a list of test vectors.

    Args:
        test_vectors (list): A list of dictionaries, where each dictionary
                             represents a test vector with message, public key, signature, and expected result.
        vector_type (str): Type of vectors - "sigver" or "siggen"

    Returns:
        str: The complete C header file content as a string.
    """
    header_content = []
    header_content.append("/* This file is automatically generated. Do not edit. */")
    header_content.append("/* ECDSA P-256 SHA-256 test vectors from NIST RSP files */\n")
    
    if vector_type == "siggen":
        header_content.append("#ifndef ECDSA_P256_SIGGEN_TEST_VECTORS_H")
        header_content.append("#define ECDSA_P256_SIGGEN_TEST_VECTORS_H")
        header_content.append("\n#include <stdint.h>")
        header_content.append("#include <stddef.h>\n")
        header_content.append("typedef struct {")
        header_content.append("    const uint8_t *message;")
        header_content.append("    const size_t message_len;")
        header_content.append("    const uint8_t private_key[32];")
        header_content.append("    const uint8_t public_key[65];    /* 0x04 + x + y */")
        header_content.append("    const uint8_t nonce[32];")
        header_content.append("    const uint8_t signature[64];     /* r + s */")
        header_content.append("} EcdsaSigGenTestVector;\n")
        
        # Define all message arrays first
        for i, vector in enumerate(test_vectors):
            message_hex = ", ".join([f"0x{byte:02x}" for byte in vector['message']])
            if vector['message']:
                header_content.append(f"static const uint8_t siggen_message_{i}[] = {{{message_hex}}};")
        
        # Define the main test vector array
        header_content.append("\nstatic const EcdsaSigGenTestVector ecdsa_p256_siggen_test_vectors[] = {")
        for i, vector in enumerate(test_vectors):
            message_len = len(vector['message'])
            
            # Format arrays as hex
            private_key_hex = ", ".join([f"0x{byte:02x}" for byte in vector['private_key']])
            public_key_hex = ", ".join([f"0x{byte:02x}" for byte in vector['public_key']])
            nonce_hex = ", ".join([f"0x{byte:02x}" for byte in vector['nonce']])
            signature_hex = ", ".join([f"0x{byte:02x}" for byte in vector['signature']])
            
            if message_len == 0:
                header_content.append(f"    {{NULL, 0,")
            else:
                header_content.append(f"    {{siggen_message_{i}, sizeof(siggen_message_{i}),")
            
            header_content.append(f"     {{{private_key_hex}}},")
            header_content.append(f"     {{{public_key_hex}}},")
            header_content.append(f"     {{{nonce_hex}}},")
            header_content.append(f"     {{{signature_hex}}} }},")
        
        header_content.append("};")
        header_content.append(f"\nstatic const size_t num_ecdsa_p256_siggen_test_vectors = {len(test_vectors)};\n")
        header_content.append("#endif // ECDSA_P256_SIGGEN_TEST_VECTORS_H")
        
    else:  # sigver
        header_content.append("#ifndef ECDSA_P256_SIGVER_TEST_VECTORS_H")
        header_content.append("#define ECDSA_P256_SIGVER_TEST_VECTORS_H")
        header_content.append("\n#include <stdint.h>")
        header_content.append("#include <stddef.h>")
        header_content.append("#include \"p256.h\"\n")
        header_content.append("typedef struct {")
        header_content.append("    const uint8_t *message;")
        header_content.append("    const size_t message_len;")
        header_content.append("    const uint8_t public_key[65];    /* 0x04 + x + y */")
        header_content.append("    const uint8_t signature[64];     /* r + s */")
        header_content.append("    const p256_ret_t expected_result; /* P256_SUCCESS or P256_INVALID_SIGNATURE */")
        header_content.append("} EcdsaSigVerTestVector;\n")

        # Define all message arrays first
        for i, vector in enumerate(test_vectors):
            message_hex = ", ".join([f"0x{byte:02x}" for byte in vector['message']])
            if vector['message']:
                header_content.append(f"static const uint8_t sigver_message_{i}[] = {{{message_hex}}};")

        # Define the main test vector array
        header_content.append("\nstatic const EcdsaSigVerTestVector ecdsa_p256_sigver_test_vectors[] = {")
        for i, vector in enumerate(test_vectors):
            message_len = len(vector['message'])
            
            # Format arrays as hex
            public_key_hex = ", ".join([f"0x{byte:02x}" for byte in vector['public_key']])
            signature_hex = ", ".join([f"0x{byte:02x}" for byte in vector['signature']])
            
            if message_len == 0:
                header_content.append(f"    {{NULL, 0,")
            else:
                header_content.append(f"    {{sigver_message_{i}, sizeof(sigver_message_{i}),")
            
            header_content.append(f"     {{{public_key_hex}}},")
            header_content.append(f"     {{{signature_hex}}},")
            header_content.append(f"     {vector['expected_result']} }},")

        header_content.append("};")
        header_content.append(f"\nstatic const size_t num_ecdsa_p256_sigver_test_vectors = {len(test_vectors)};\n")
        header_content.append("#endif // ECDSA_P256_SIGVER_TEST_VECTORS_H")

    return "\n".join(header_content)

def parse_sigver_rsp_file(file_path):
    """
    Parses a NIST ECDSA SigVer .rsp file for P-256 SHA-256 test vectors.

    Args:
        file_path (str): The path to the .rsp file.

    Returns:
        list: A list of signature verification test vectors.
    """
    test_vectors = []
    current_section = None
    current_vector = {}
    
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            
            # Skip comments and empty lines
            if line.startswith('#') or not line:
                continue
            
            # Check for curve/hash section
            if line.startswith('[') and line.endswith(']'):
                current_section = line[1:-1]
                continue
            
            # Only process P-256,SHA-256 vectors
            if current_section != 'P-256,SHA-256':
                continue
            
            # Parse key-value pairs
            if '=' in line:
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                if key == 'Msg':
                    current_vector['msg_hex'] = value
                elif key == 'Qx':
                    current_vector['qx_hex'] = value
                elif key == 'Qy':
                    current_vector['qy_hex'] = value
                elif key == 'R':
                    current_vector['r_hex'] = value
                elif key == 'S':
                    current_vector['s_hex'] = value
                elif key == 'Result':
                    current_vector['result'] = value.split()[0]  # Extract P or F
                    
                    # When we have a complete test vector, process it
                    if all(k in current_vector for k in ['msg_hex', 'qx_hex', 'qy_hex', 'r_hex', 's_hex', 'result']):
                        try:
                            # Convert hex strings to bytes
                            message = bytes.fromhex(current_vector['msg_hex'])
                            qx = bytes.fromhex(current_vector['qx_hex'])
                            qy = bytes.fromhex(current_vector['qy_hex'])
                            r = bytes.fromhex(current_vector['r_hex'])
                            s = bytes.fromhex(current_vector['s_hex'])
                            
                            # Format public key: 0x04 + x + y
                            public_key = b'\x04' + qx + qy
                            
                            # Format signature: r + s
                            signature = r + s
                            
                            # Expected result
                            expected_result = "P256_SUCCESS" if current_vector['result'] == 'P' else "P256_INVALID_SIGNATURE"
                            
                            test_vectors.append({
                                'message': message,
                                'public_key': public_key,
                                'signature': signature,
                                'expected_result': expected_result
                            })
                        except ValueError as e:
                            print(f"Warning: Skipping invalid test vector: {e}")
                        
                        current_vector = {}

    return test_vectors

def parse_siggen_rsp_file(file_path):
    """
    Parses a NIST ECDSA SigGen .rsp or .txt file for P-256 SHA-256 test vectors.

    Args:
        file_path (str): The path to the .rsp or .txt file.

    Returns:
        list: A list of signature generation test vectors.
    """
    test_vectors = []
    current_section = None
    current_vector = {}
    
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            
            # Skip comments and empty lines
            if line.startswith('#') or not line:
                continue
            
            # Check for curve/hash section
            if line.startswith('[') and line.endswith(']'):
                current_section = line[1:-1]
                continue
            
            # Only process P-256,SHA-256 vectors
            if current_section != 'P-256,SHA-256':
                continue
            
            # Parse key-value pairs
            if '=' in line:
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                if key == 'Msg':
                    current_vector['msg_hex'] = value
                elif key == 'd':
                    current_vector['d_hex'] = value
                elif key == 'Qx':
                    current_vector['qx_hex'] = value
                elif key == 'Qy':
                    current_vector['qy_hex'] = value
                elif key == 'k':
                    current_vector['k_hex'] = value
                elif key == 'R':
                    current_vector['r_hex'] = value
                elif key == 'S':
                    current_vector['s_hex'] = value
                    
                    # When we have a complete test vector with private key info, process it
                    required_keys = ['msg_hex', 'qx_hex', 'qy_hex', 'r_hex', 's_hex']
                    optional_keys = ['d_hex', 'k_hex']  # These might not be in all files
                    
                    if all(k in current_vector for k in required_keys):
                        try:
                            # Convert hex strings to bytes
                            message = bytes.fromhex(current_vector['msg_hex'])
                            qx = bytes.fromhex(current_vector['qx_hex'])
                            qy = bytes.fromhex(current_vector['qy_hex'])
                            r = bytes.fromhex(current_vector['r_hex'])
                            s = bytes.fromhex(current_vector['s_hex'])
                            
                            # Format public key: 0x04 + x + y
                            public_key = b'\x04' + qx + qy
                            
                            # Format signature: r + s
                            signature = r + s
                            
                            # Private key and nonce (if available)
                            private_key = bytes.fromhex(current_vector.get('d_hex', '00' * 32))
                            nonce = bytes.fromhex(current_vector.get('k_hex', '00' * 32))
                            
                            test_vectors.append({
                                'message': message,
                                'private_key': private_key,
                                'public_key': public_key,
                                'nonce': nonce,
                                'signature': signature
                            })
                        except ValueError as e:
                            print(f"Warning: Skipping invalid test vector: {e}")
                        
                        current_vector = {}

    return test_vectors

def detect_file_type(file_path):
    """
    Detects whether a file is a signature generation or verification file.
    
    Args:
        file_path (str): Path to the RSP file
        
    Returns:
        str: "siggen" for signature generation, "sigver" for verification
    """
    filename = os.path.basename(file_path).lower()
    if 'siggen' in filename:
        return "siggen"
    elif 'sigver' in filename:
        return "sigver"
    else:
        # Try to detect by content
        with open(file_path, 'r') as f:
            content = f.read()
            if 'Result =' in content:
                return "sigver"
            elif 'd =' in content or 'k =' in content:
                return "siggen"
    return "sigver"  # default

def main():
    """
    Main function to parse command-line arguments and run the script.
    """
    parser = argparse.ArgumentParser(
        description="Parse NIST ECDSA P-256 SHA-256 .rsp files and generate C header files.",
        epilog="Example: python %(prog)s -o ecdsa_test_vectors.h rsp/SigVer.rsp"
    )
    parser.add_argument(
        "-o", "--output",
        required=True,
        dest="output_file",
        help="The path for the output .h file."
    )
    parser.add_argument(
        "input_files",
        nargs='+',
        help="One or more input .rsp files to parse."
    )
    parser.add_argument(
        "--type",
        choices=["auto", "sigver", "siggen"],
        default="auto",
        help="Force the type of test vectors. 'auto' detects based on filename/content."
    )
    parser.add_argument(
        "--limit",
        type=int,
        default=None,
        help="Limit the number of test vectors to include (for testing)."
    )
    args = parser.parse_args()

    all_test_vectors = []
    parsed_files_count = 0
    vector_type = None
    
    for input_path in args.input_files:
        try:
            print(f"Parsing {input_path}...")
            
            # Determine file type
            if args.type == "auto":
                file_type = detect_file_type(input_path)
            else:
                file_type = args.type
            
            # Set the vector type for the output (all files should be the same type)
            if vector_type is None:
                vector_type = file_type
            elif vector_type != file_type:
                print(f"  -> Warning: Mixed file types detected. All files should be the same type.")
                print(f"     Expected: {vector_type}, Found: {file_type}")
                continue
            
            # Parse the file based on its type
            if file_type == "siggen":
                test_vectors = parse_siggen_rsp_file(input_path)
            else:
                test_vectors = parse_sigver_rsp_file(input_path)
            
            if not test_vectors:
                print(f"  -> Warning: No P-256 SHA-256 test vectors found.")
            else:
                all_test_vectors.extend(test_vectors)
                print(f"  -> Found {len(test_vectors)} P-256 SHA-256 vectors (type: {file_type}).")
                parsed_files_count += 1
                
        except FileNotFoundError:
            print(f"  -> Error: File not found. Skipping.")
        except Exception as e:
            print(f"  -> An error occurred while parsing: {e}. Skipping.")

    if not all_test_vectors:
        print("\nNo test vectors were successfully parsed. Output file will not be generated.")
        return

    # Apply limit if specified
    if args.limit and args.limit < len(all_test_vectors):
        all_test_vectors = all_test_vectors[:args.limit]
        print(f"Limited to first {args.limit} test vectors.")

    print(f"\nTotal test vectors collected: {len(all_test_vectors)} from {parsed_files_count} file(s).")
    print(f"Vector type: {vector_type}")

    try:
        c_header_content = generate_c_header(all_test_vectors, vector_type)
        with open(args.output_file, 'w') as f:
            f.write(c_header_content)
        print(f"Successfully created {args.output_file}.")
    except Exception as e:
        print(f"\nAn error occurred while writing the output file: {e}")

if __name__ == "__main__":
    main()
