#!/usr/bin/env python3
"""
CRC32 Test Vector Generator

This script generates test vectors for CRC32 implementation and creates a C header file.
It generates various test messages of different lengths and computes their CRC32 values
using the same polynomial as the C implementation (IEEE 802.3 standard).

Usage:
    python generate_crc32_vectors.py -o test_vectors.h
    python generate_crc32_vectors.py -o test_vectors.h --num-vectors 20
"""

import argparse
import random
import struct
from typing import List, Dict

def crc32_ieee802_3(data: bytes) -> int:
    """
    Compute CRC32 using IEEE 802.3 polynomial (0xEDB88320).
    This matches the implementation in the C code.
    
    Args:
        data (bytes): Input data
        
    Returns:
        int: CRC32 value
    """
    crc = 0xFFFFFFFF
    
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 1:
                crc = (crc >> 1) ^ 0xEDB88320
            else:
                crc >>= 1
    
    return (~crc) & 0xFFFFFFFF


def generate_test_vectors(num_vectors: int = 10) -> List[Dict]:
    """
    Generate test vectors with various message patterns and lengths.
    
    Args:
        num_vectors (int): Number of test vectors to generate
        
    Returns:
        List[Dict]: List of test vectors with 'message' and 'crc32' keys
    """
    test_vectors = []
    random.seed(42)  # Reproducible results
    
    # Test vector 0: Empty message
    test_vectors.append({
        'message': b'',
        'crc32': crc32_ieee802_3(b'')
    })
    
    # Test vector 1: Single byte
    test_vectors.append({
        'message': b'A',
        'crc32': crc32_ieee802_3(b'A')
    })
    
    # Test vector 2: "Hello, World!"
    hello_world = b"Hello, World!"
    test_vectors.append({
        'message': hello_world,
        'crc32': crc32_ieee802_3(hello_world)
    })
    
    # Test vector 3: All zeros (8 bytes)
    zeros_8 = b'\x00' * 8
    test_vectors.append({
        'message': zeros_8,
        'crc32': crc32_ieee802_3(zeros_8)
    })
    
    # Test vector 4: All 0xFF (16 bytes)
    ones_16 = b'\xFF' * 16
    test_vectors.append({
        'message': ones_16,
        'crc32': crc32_ieee802_3(ones_16)
    })
    
    # Test vector 5: Incrementing bytes 0x00 to 0xFF
    incrementing = bytes(range(256))
    test_vectors.append({
        'message': incrementing,
        'crc32': crc32_ieee802_3(incrementing)
    })
    
    # Test vector 6: Repeating pattern "0x12345678"
    pattern = b'\x12\x34\x56\x78' * 32  # 128 bytes
    test_vectors.append({
        'message': pattern,
        'crc32': crc32_ieee802_3(pattern)
    })
    
    # Test vector 7: ASCII alphabet
    alphabet = b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    test_vectors.append({
        'message': alphabet,
        'crc32': crc32_ieee802_3(alphabet)
    })
    
    # Generate additional random vectors
    for i in range(8, min(num_vectors, 8 + 50)):  # Cap at reasonable number
        # Random length between 1 and 1024 bytes
        length = random.randint(1, 1024)
        
        # Generate random message with various patterns
        if i % 4 == 0:
            # Random bytes
            message = bytes([random.randint(0, 255) for _ in range(length)])
        elif i % 4 == 1:
            # Repeated single byte
            byte_val = random.randint(0, 255)
            message = bytes([byte_val] * length)
        elif i % 4 == 2:
            # Repeated short pattern
            pattern_len = random.randint(2, 8)
            pattern = bytes([random.randint(0, 255) for _ in range(pattern_len)])
            message = (pattern * ((length // pattern_len) + 1))[:length]
        else:
            # Mix of patterns
            part1 = bytes([0x00] * (length // 3))
            part2 = bytes([0xFF] * (length // 3))
            part3 = bytes([random.randint(0, 255) for _ in range(length - 2 * (length // 3))])
            message = part1 + part2 + part3
        
        test_vectors.append({
            'message': message,
            'crc32': crc32_ieee802_3(message)
        })
    
    return test_vectors[:num_vectors]


def generate_c_header(test_vectors: List[Dict]) -> str:
    """
    Generate C header file content from test vectors.
    
    Args:
        test_vectors (List[Dict]): List of test vectors
        
    Returns:
        str: C header file content
    """
    header_content = []
    header_content.append("/* This file is automatically generated. Do not edit. */")
    header_content.append("/* CRC32 Test Vectors - IEEE 802.3 polynomial (0xEDB88320) */")
    header_content.append("")
    header_content.append("#ifndef CRC32_TEST_VECTORS_H")
    header_content.append("#define CRC32_TEST_VECTORS_H")
    header_content.append("")
    header_content.append("#include <stdint.h>")
    header_content.append("#include <stddef.h>")
    header_content.append("")
    header_content.append("typedef struct {")
    header_content.append("    const unsigned char *message;")
    header_content.append("    unsigned int message_len;")
    header_content.append("    unsigned int expected_crc32;")
    header_content.append("} CRC32TestVector;")
    header_content.append("")
    
    # Define message arrays
    for i, vector in enumerate(test_vectors):
        if len(vector['message']) > 0:
            message_hex = ", ".join([f"0x{byte:02x}" for byte in vector['message']])
            header_content.append(f"static const unsigned char message_{i}[] = {{{message_hex}}};")
        else:
            # For empty message, we'll use NULL
            pass
    
    header_content.append("")
    
    # Define the test vector array
    header_content.append("static const CRC32TestVector crc32_test_vectors[] = {")
    
    for i, vector in enumerate(test_vectors):
        message_len = len(vector['message'])
        crc32_val = vector['crc32']
        
        if message_len == 0:
            # Handle empty message
            header_content.append(f"    {{NULL, 0, 0x{crc32_val:08x}U}},")
        else:
            header_content.append(f"    {{message_{i}, {message_len}, 0x{crc32_val:08x}U}},")
    
    header_content.append("};")
    header_content.append("")
    header_content.append(f"static const size_t num_crc32_test_vectors = {len(test_vectors)};")
    header_content.append("")
    header_content.append("#endif /* CRC32_TEST_VECTORS_H */")
    
    return "\n".join(header_content)


def verify_with_known_values():
    """
    Verify our CRC32 implementation with known test values.
    """
    known_tests = [
        (b"", 0x00000000),
        (b"a", 0xe8b7be43),
        (b"abc", 0x352441c2),
        (b"message digest", 0x20159d7f),
        (b"abcdefghijklmnopqrstuvwxyz", 0x4c2750bd),
        (b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", 0x1fc2e6d2),
        (b"1234567890" * 8, 0x7ca94a72),
    ]
    
    print("Verifying CRC32 implementation with known values:")
    all_passed = True
    
    for data, expected in known_tests:
        computed = crc32_ieee802_3(data)
        passed = computed == expected
        status = "PASS" if passed else "FAIL"
        print(f"  {repr(data[:20]):<25} Expected: 0x{expected:08x}, Got: 0x{computed:08x} [{status}]")
        if not passed:
            all_passed = False
    
    if all_passed:
        print("All verification tests passed!")
    else:
        print("Some verification tests failed!")
    
    return all_passed


def main():
    """
    Main function to parse command-line arguments and generate test vectors.
    """
    parser = argparse.ArgumentParser(
        description="Generate CRC32 test vectors and create a C header file.",
        epilog="Example: python %(prog)s -o test_vectors.h --num-vectors 15"
    )
    parser.add_argument(
        "-o", "--output",
        required=True,
        dest="output_file",
        help="The path for the output .h file."
    )
    parser.add_argument(
        "--num-vectors",
        type=int,
        default=10,
        help="Number of test vectors to generate (default: 10, max: 58)"
    )
    parser.add_argument(
        "--verify",
        action="store_true",
        help="Verify CRC32 implementation with known test values"
    )
    
    args = parser.parse_args()
    
    # Verify implementation if requested
    if args.verify:
        if not verify_with_known_values():
            print("Verification failed. Exiting.")
            return 1
        print()
    
    # Limit the number of vectors to a reasonable amount
    num_vectors = min(args.num_vectors, 58)
    if args.num_vectors > 58:
        print(f"Warning: Limiting number of vectors to 58 (requested: {args.num_vectors})")
    
    print(f"Generating {num_vectors} CRC32 test vectors...")
    
    try:
        # Generate test vectors
        test_vectors = generate_test_vectors(num_vectors)
        
        # Generate C header content
        c_header_content = generate_c_header(test_vectors)
        
        # Write to file
        with open(args.output_file, 'w') as f:
            f.write(c_header_content)
        
        print(f"Successfully created {args.output_file} with {len(test_vectors)} test vectors.")
        
        # Show some statistics
        msg_lengths = [len(v['message']) for v in test_vectors]
        print(f"Message lengths: min={min(msg_lengths)}, max={max(msg_lengths)}, avg={sum(msg_lengths)/len(msg_lengths):.1f}")
        
    except Exception as e:
        print(f"Error: {e}")
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())
